// Package declaration for the ViewBinding IDEA plugin module.
package com.adkhambek.viewbinding.idea

// Import AbstractDocumentationProvider for custom Quick Documentation popups.
import com.intellij.lang.documentation.AbstractDocumentationProvider
// Import PsiElement, the base class for PSI tree nodes.
import com.intellij.psi.PsiElement
// Import analyze for Kotlin Analysis API operations.
import org.jetbrains.kotlin.analysis.api.analyze
// Import ClassId for annotation class identification.
import org.jetbrains.kotlin.name.ClassId
// Import FqName for fully qualified names.
import org.jetbrains.kotlin.name.FqName
// Import Name for simple identifiers.
import org.jetbrains.kotlin.name.Name
// Import KtClassOrObject for class/object PSI declarations.
import org.jetbrains.kotlin.psi.KtClassOrObject
// Import KtProperty for property PSI declarations.
import org.jetbrains.kotlin.psi.KtProperty

// Documentation provider that generates Quick Documentation (Ctrl+Q / F1) for the
// ViewBinding compiler plugin's generated `binding` property.
// When a developer hovers over or requests documentation for the `binding` property
// in a @Screen-annotated Fragment class, this provider shows:
//   - The property declaration with its type
//   - A note that it was generated by the ViewBinding compiler plugin
//   - How the binding is created (via bind(requireView()))
//
// Registered in plugin.xml as a lang.documentationProvider for the Kotlin language.
class ViewBindingDocumentationProvider : AbstractDocumentationProvider() {

    // ClassId for the @Screen annotation.
    private val screenClassId = ClassId(
        FqName("com.adkhambek.screen"),
        Name.identifier("Screen"),
    )

    // Called by the IDE when documentation is requested for a PSI element.
    // Returns HTML documentation for the generated binding property, or null if not applicable.
    override fun generateDoc(element: PsiElement, originalElement: PsiElement?): String? {
        // Only handle property declarations.
        val property = element as? KtProperty ?: return null
        val propName = property.name ?: return null
        // Only handle the "binding" property.
        if (propName != "binding") return null

        // Navigate to the owner class (the @Screen-annotated Fragment).
        // PSI tree: KtProperty -> KtClassBody -> KtClassOrObject
        val ownerClass = property.parent?.parent as? KtClassOrObject ?: return null
        // Verify the owner class has the @Screen annotation.
        if (!hasScreenAnnotation(ownerClass)) return null

        // Get the binding type from the property's type reference (e.g., FragmentSampleBinding).
        val bindingType = property.typeReference?.text ?: "ViewBinding"

        // Build and return the HTML documentation.
        return buildString {
            // Definition section: shows the property declaration.
            append("<div class='definition'><pre>")
            append("private val binding: $bindingType")
            append("  // type: $bindingType")
            append("</pre></div>")
            // Content section: generation notice and description.
            append("<div class='content'>")
            append("<p><i>Generated by the ViewBinding compiler plugin</i></p>")
            append("<p>View binding instance created by calling <code>bind(requireView())</code> on each access.</p>")
            append("</div>")
        }
    }

    // Checks whether a class or object has the @Screen annotation using the Analysis API.
    private fun hasScreenAnnotation(classOrObject: KtClassOrObject): Boolean {
        analyze(classOrObject) {
            val symbol = classOrObject.symbol
            return symbol.annotations.any { it.classId == screenClassId }
        }
    }
}
