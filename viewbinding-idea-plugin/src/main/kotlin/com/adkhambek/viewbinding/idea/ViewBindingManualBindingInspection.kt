// Package declaration for the ViewBinding IDEA plugin module.
package com.adkhambek.viewbinding.idea

// Import LocalInspectionTool for file-level code inspections.
import com.intellij.codeInspection.LocalInspectionTool
// Import ProblemsHolder for collecting inspection problems.
import com.intellij.codeInspection.ProblemsHolder
// Import PsiElementVisitor for PSI tree traversal.
import com.intellij.psi.PsiElementVisitor
// Import analyze for Kotlin Analysis API operations.
import org.jetbrains.kotlin.analysis.api.analyze
// Import ClassId for annotation class identification.
import org.jetbrains.kotlin.name.ClassId
// Import FqName for fully qualified names.
import org.jetbrains.kotlin.name.FqName
// Import Name for simple identifiers.
import org.jetbrains.kotlin.name.Name
// Import KtClassOrObject for class/object PSI declarations.
import org.jetbrains.kotlin.psi.KtClassOrObject
// Import KtProperty for property PSI declarations.
import org.jetbrains.kotlin.psi.KtProperty
// Import KtVisitorVoid for Kotlin PSI visiting.
import org.jetbrains.kotlin.psi.KtVisitorVoid

// Code inspection that warns developers when they manually define a "binding" property
// in a @Screen-annotated Fragment class. Since the ViewBinding compiler plugin
// automatically generates the binding property, a manual definition would conflict with it.
//
// Registered in plugin.xml as a localInspection with:
//   - shortName: "ViewBindingManualBinding"
//   - groupName: "ViewBinding"
//   - level: WARNING
//   - enabledByDefault: true
class ViewBindingManualBindingInspection : LocalInspectionTool() {

    // ClassId for the @Screen annotation.
    private val screenClassId = ClassId(
        FqName("com.adkhambek.screen"),
        Name.identifier("Screen"),
    )

    // Builds a PSI visitor that checks for conflicting manual binding definitions.
    // Traverses all properties and flags those named "binding" in @Screen classes.
    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
        return object : KtVisitorVoid() {
            // Called for each property declaration in the file.
            override fun visitProperty(property: KtProperty) {
                val name = property.name ?: return
                // Only check properties named "binding".
                if (name != "binding") return

                // Navigate to the owner class.
                // PSI tree: KtProperty -> KtClassBody -> KtClassOrObject
                val ownerClass = property.parent?.parent as? KtClassOrObject ?: return
                // Verify the owner has @Screen annotation.
                if (!hasScreenAnnotation(ownerClass)) return

                // Register a warning on the property's name identifier.
                holder.registerProblem(
                    property.nameIdentifier ?: property,
                    "'binding' is automatically generated by the ViewBinding compiler plugin for @Screen classes. This manual definition will conflict with the generated property.",
                )
            }
        }
    }

    // Checks whether a class or object has the @Screen annotation using the Analysis API.
    private fun hasScreenAnnotation(classOrObject: KtClassOrObject): Boolean {
        analyze(classOrObject) {
            val symbol = classOrObject.symbol
            return symbol.annotations.any { it.classId == screenClassId }
        }
    }
}
