// Suppress INVISIBLE_MEMBER warnings for accessing internal Kotlin compiler APIs.
@file:Suppress("INVISIBLE_MEMBER")

// Package declaration for the IR phase of the ViewBinding compiler plugin.
package com.adkhambek.viewbinding.compiler.ir

// Import ViewBindingDeclarationKey to identify declarations generated by this plugin.
import com.adkhambek.viewbinding.compiler.fir.ViewBindingDeclarationKey
// Import IrPluginContext for accessing IR type system, symbols, and factory.
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
// Import DeclarationIrBuilder for building IR expression trees.
import org.jetbrains.kotlin.backend.common.lower.DeclarationIrBuilder
// Import DescriptorVisibilities for setting visibility of generated declarations.
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
// Import Modality for setting modality of generated declarations.
import org.jetbrains.kotlin.descriptors.Modality
// Import IrStatement, the base type for IR statements.
import org.jetbrains.kotlin.ir.IrStatement
// Import addField for adding fields to IR class declarations.
import org.jetbrains.kotlin.ir.builders.declarations.addField
// Import addValueParameter for adding parameters to IR functions.
import org.jetbrains.kotlin.ir.builders.declarations.addValueParameter
// Import buildFun for building IR function declarations.
import org.jetbrains.kotlin.ir.builders.declarations.buildFun
// Import irBlockBody for creating IR block bodies.
import org.jetbrains.kotlin.ir.builders.irBlockBody
// Import irCall for creating IR function call expressions.
import org.jetbrains.kotlin.ir.builders.irCall
// Import irCallConstructor for creating IR constructor call expressions.
import org.jetbrains.kotlin.ir.builders.irCallConstructor
// Import irGet for creating IR variable read expressions.
import org.jetbrains.kotlin.ir.builders.irGet
// Import irGetField for creating IR field read expressions.
import org.jetbrains.kotlin.ir.builders.irGetField
// Import irInt for creating IR integer constant expressions.
import org.jetbrains.kotlin.ir.builders.irInt
// Import irReturn for creating IR return statements.
import org.jetbrains.kotlin.ir.builders.irReturn
// Import irString for creating IR string constant expressions.
import org.jetbrains.kotlin.ir.builders.irString
// Import IrClass representing a class in the IR tree.
import org.jetbrains.kotlin.ir.declarations.IrClass
// Import IrDeclarationOrigin for checking/setting the origin of IR declarations.
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
// Import IrParameterKind to distinguish parameter types.
import org.jetbrains.kotlin.ir.declarations.IrParameterKind
// Import IrProperty representing a property in the IR tree.
import org.jetbrains.kotlin.ir.declarations.IrProperty
// Import IrStatementOrigin for marking statement origins (e.g., LAMBDA).
import org.jetbrains.kotlin.ir.expressions.IrStatementOrigin
// Import IrFunctionExpressionImpl for creating lambda expression nodes.
import org.jetbrains.kotlin.ir.expressions.impl.IrFunctionExpressionImpl
// Import UnsafeDuringIrConstructionAPI opt-in for accessing IR symbols during construction.
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
// Import classOrNull for safely getting IrClassSymbol from IrType.
import org.jetbrains.kotlin.ir.types.classOrNull
// Import typeWith for creating parameterized types.
import org.jetbrains.kotlin.ir.types.typeWith
// Import constructors for iterating over class constructors.
import org.jetbrains.kotlin.ir.util.constructors
// Import defaultType for getting the non-parameterized type of a class.
import org.jetbrains.kotlin.ir.util.defaultType
// Import functions for iterating over class functions.
import org.jetbrains.kotlin.ir.util.functions
// Import kotlinFqName for getting the FQN of an IR declaration.
import org.jetbrains.kotlin.ir.util.kotlinFqName
// Import parentClassOrNull for getting the parent class.
import org.jetbrains.kotlin.ir.util.parentClassOrNull
// Import IrElementTransformerVoid for visiting and transforming IR elements.
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
// Import CallableId for looking up functions by qualified name.
import org.jetbrains.kotlin.name.CallableId
// Import ClassId for looking up classes.
import org.jetbrains.kotlin.name.ClassId
// Import FqName for fully qualified names.
import org.jetbrains.kotlin.name.FqName
// Import Name for simple identifiers.
import org.jetbrains.kotlin.name.Name

// ClassId for AndroidX Fragment.
private val FRAGMENT_CLASS_ID = ClassId(
    FqName("androidx.fragment.app"),
    Name.identifier("Fragment"),
)

// ClassId for java.lang.Class, used for Class.forName() in the delegate KProperty.
private val JAVA_CLASS_ID = ClassId(
    FqName("java.lang"),
    Name.identifier("Class"),
)

// ClassId for the ViewBindingProperty class from the VBPD library.
// This is the delegate type used when the VBPD library is available.
private val VIEW_BINDING_PROPERTY_CLASS_ID = ClassId(
    FqName("dev.androidbroadcast.vbpd"),
    Name.identifier("ViewBindingProperty"),
)

// ClassId for kotlin.jvm.internal.PropertyReference1Impl.
// Used to create the static KProperty field required by Kotlin's property delegate protocol.
private val PROPERTY_REFERENCE_1_IMPL_CLASS_ID = ClassId(
    FqName("kotlin.jvm.internal"),
    Name.identifier("PropertyReference1Impl"),
)

// ClassId for kotlin.properties.ReadOnlyProperty.
// The getValue function on this interface is called by the delegate getter.
private val READ_ONLY_PROPERTY_CLASS_ID = ClassId(
    FqName("kotlin.properties"),
    Name.identifier("ReadOnlyProperty"),
)

// Package containing the VBPD library's viewBinding extension function.
private val VBPD_PACKAGE = FqName("dev.androidbroadcast.vbpd")
// Name of the viewBinding extension function.
private val VIEW_BINDING_FN_NAME = Name.identifier("viewBinding")

// Utility function to count only regular parameters (excluding dispatch/extension receivers).
private fun regularParameterCount(params: List<org.jetbrains.kotlin.ir.declarations.IrValueParameter>): Int =
    params.count { it.kind == IrParameterKind.Regular }

// IR element transformer that generates the binding getter body for ViewBinding plugin.
// This transformer visits all IR properties, checks if they were generated by
// ViewBindingDeclarationKey, and fills in their getter bodies.
//
// Two strategies are used:
//   1. Delegate approach (preferred): Uses VBPD library's viewBinding() delegate
//      - Creates a static KProperty field (binding$kprop)
//      - Creates an instance delegate field (binding$delegate)
//      - Getter calls delegate.getValue(this, kprop)
//   2. Direct approach (fallback): Calls XxxBinding.bind(requireView()) directly
//      - No caching — binding is recreated on every access
//      - Used when VBPD library is not available
@OptIn(UnsafeDuringIrConstructionAPI::class)
class ViewBindingIrElementTransformer(
    private val pluginContext: IrPluginContext,
) : IrElementTransformerVoid() {

    // Visits property declarations and generates bodies for the "binding" property.
    override fun visitProperty(declaration: IrProperty): IrStatement {
        // Check if this property was generated by the ViewBinding plugin.
        val origin = declaration.origin as? IrDeclarationOrigin.GeneratedByPlugin
            ?: return super.visitProperty(declaration)
        if (origin.pluginKey != ViewBindingDeclarationKey) return super.visitProperty(declaration)
        // Only handle the "binding" property.
        if (declaration.name.asString() != "binding") return super.visitProperty(declaration)

        val parentClass = declaration.parentClassOrNull ?: return super.visitProperty(declaration)

        // Try the delegate approach first (using VBPD library).
        // Falls back to the direct bind() approach if VBPD is not available.
        if (!generateBindingWithDelegate(declaration, parentClass)) {
            generateDirectBindingGetter(declaration, parentClass)
        }

        // Mark the getter origin as DEFINED to prevent JvmPropertiesLowering from replacing
        // getter calls with direct field access (the binding has no backing field).
        declaration.getter?.origin = IrDeclarationOrigin.DEFINED
        return declaration
    }

    // Generates the binding property using the VBPD delegate approach.
    // This creates three things on the parent class:
    //   1. A static KProperty field: binding$kprop (PropertyReference1Impl)
    //   2. An instance delegate field: binding$delegate (ViewBindingProperty<Fragment, XxxBinding>)
    //   3. A getter that calls: binding$delegate.getValue(this, binding$kprop)
    //
    // The delegate approach provides lifecycle-aware caching — the binding is created lazily
    // and cleared when the Fragment's view is destroyed.
    //
    // Returns true if the delegate approach was successfully applied, false if VBPD is not available.
    private fun generateBindingWithDelegate(
        declaration: IrProperty,
        parentClass: IrClass,
    ): Boolean {
        val getter = declaration.getter ?: return false
        val bindingType = getter.returnType
        val bindingClass = bindingType.classOrNull?.owner ?: return false

        // Verify all required symbols exist BEFORE creating any fields.
        // This prevents partially-constructed state if a symbol lookup fails.
        val fragmentClass = pluginContext.referenceClass(FRAGMENT_CLASS_ID)!!

        // Find the non-inline viewBinding extension function on Fragment with 1 regular parameter.
        // The VBPD library provides multiple overloads; we need the one that takes a viewBinder lambda.
        val viewBindingFn = pluginContext.referenceFunctions(
            CallableId(VBPD_PACKAGE, VIEW_BINDING_FN_NAME)
        ).firstOrNull { ref ->
            val fn = ref.owner
            !fn.isInline && regularParameterCount(fn.parameters) == 1 &&
                fn.parameters.any {
                    it.kind == IrParameterKind.ExtensionReceiver &&
                        it.type.classOrNull == fragmentClass
                }
        }?.owner ?: return false

        // Resolve ReadOnlyProperty.getValue(thisRef, property) for the delegate protocol.
        val readOnlyPropertyClass = pluginContext.referenceClass(READ_ONLY_PROPERTY_CLASS_ID)
            ?: return false
        val getValueFn = readOnlyPropertyClass.owner.functions.first {
            it.name.asString() == "getValue" && regularParameterCount(it.parameters) == 2
        }

        // Resolve PropertyReference1Impl constructor for the KProperty field.
        val propRef1ImplClass = pluginContext.referenceClass(PROPERTY_REFERENCE_1_IMPL_CLASS_ID)
            ?: return false
        val propRef1ImplConstructor = propRef1ImplClass.owner.constructors.first {
            regularParameterCount(it.parameters) == 4
        }

        // Resolve Fragment.requireView() for the binding lambda.
        val requireViewFn = fragmentClass.owner.functions.first {
            it.name.asString() == "requireView" && regularParameterCount(it.parameters) == 0
        }
        // Resolve XxxBinding.bind(View) static function for creating the binding.
        val bindFn = bindingClass.functions.firstOrNull {
            it.name.asString() == "bind" && regularParameterCount(it.parameters) == 1
        } ?: return false

        // Resolve Class.forName(String) for the KProperty constructor.
        val javaLangClass = pluginContext.referenceClass(JAVA_CLASS_ID)!!
        val forNameFn = javaLangClass.owner.functions.first {
            it.name.asString() == "forName" && regularParameterCount(it.parameters) == 1
        }

        val thisReceiver = parentClass.thisReceiver ?: return false

        // All symbols resolved — safe to create fields.

        val fragmentType = fragmentClass.owner.defaultType
        // ViewBindingProperty<Fragment, XxxBinding> — the delegate type.
        val viewBindingPropertyClass = pluginContext.referenceClass(VIEW_BINDING_PROPERTY_CLASS_ID)!!
        val delegateType = viewBindingPropertyClass.typeWith(fragmentType, bindingType)

        val s = declaration.startOffset
        val e = declaration.endOffset

        // 1. Create the static KProperty field: binding$kprop.
        // This is required by Kotlin's property delegate protocol (getValue receives a KProperty).
        // PropertyReference1Impl(ownerClass, propertyName, getterSignature, flags)
        val kPropField = parentClass.addField {
            startOffset = s
            endOffset = e
            name = Name.identifier("binding\$kprop")
            type = propRef1ImplClass.owner.defaultType
            visibility = DescriptorVisibilities.PRIVATE
            isFinal = true
            isStatic = true
        }

        // Build the PropertyReference1Impl constructor arguments.
        val parentFqName = parentClass.kotlinFqName.asString()
        val bindingInternalName = bindingClass.kotlinFqName.asString().replace('.', '/')
        val getterSignature = "getBinding()L${bindingInternalName};"

        // Initialize the static field with a PropertyReference1Impl instance.
        kPropField.initializer = pluginContext.irFactory.createExpressionBody(
            s, e,
            DeclarationIrBuilder(pluginContext, kPropField.symbol).run {
                irCallConstructor(propRef1ImplConstructor.symbol, emptyList()).apply {
                    // Arg 0: owner class (java.lang.Class)
                    arguments[0] = irCall(forNameFn).apply {
                        arguments[0] = irString(parentFqName)
                    }
                    // Arg 1: property name
                    arguments[1] = irString("binding")
                    // Arg 2: getter JVM signature
                    arguments[2] = irString(getterSignature)
                    // Arg 3: flags (0 = no special flags)
                    arguments[3] = irInt(0)
                }
            }
        )

        // 2. Create the instance delegate field: binding$delegate.
        // This field holds the ViewBindingProperty delegate instance that manages
        // lifecycle-aware caching of the binding.
        val delegateField = parentClass.addField {
            startOffset = s
            endOffset = e
            name = Name.identifier("binding\$delegate")
            type = delegateType
            visibility = DescriptorVisibilities.PRIVATE
            isFinal = true
            isStatic = false
        }

        // Build the viewBinder lambda: { fragment -> XxxBinding.bind(fragment.requireView()) }
        // This lambda is called by the delegate to create the binding when needed.
        val lambdaFn = pluginContext.irFactory.buildFun {
            name = Name.special("<anonymous>")
            returnType = bindingType
            origin = IrDeclarationOrigin.LOCAL_FUNCTION_FOR_LAMBDA
            visibility = DescriptorVisibilities.LOCAL
            modality = Modality.FINAL
        }.apply {
            parent = parentClass
            val fragmentParam = addValueParameter("fragment", fragmentType)

            // Lambda body: return XxxBinding.bind(fragment.requireView())
            body = DeclarationIrBuilder(pluginContext, symbol).irBlockBody {
                +irReturn(
                    irCall(bindFn).apply {
                        // Call requireView() on the fragment to get the root view.
                        arguments[0] = irCall(requireViewFn).apply {
                            dispatchReceiver = irGet(fragmentParam)
                        }
                    }
                )
            }
        }

        // Wrap the lambda in a function expression.
        val lambdaType = pluginContext.irBuiltIns.functionN(1).typeWith(fragmentType, bindingType)
        val lambdaExpr = IrFunctionExpressionImpl(
            startOffset = s,
            endOffset = e,
            type = lambdaType,
            function = lambdaFn,
            origin = IrStatementOrigin.LAMBDA,
        )

        // Initialize the delegate field: this.viewBinding { fragment -> ... }
        // Calls the VBPD viewBinding() extension function on the Fragment.
        delegateField.initializer = pluginContext.irFactory.createExpressionBody(
            s, e,
            DeclarationIrBuilder(pluginContext, delegateField.symbol).run {
                irCall(viewBindingFn).apply {
                    type = delegateType
                    // Type arguments: F = Fragment type, T = Binding type
                    typeArguments[0] = parentClass.defaultType
                    typeArguments[1] = bindingType
                    // Extension receiver: the fragment instance (this)
                    arguments[0] = irGet(thisReceiver)
                    // Regular parameter: the viewBinder lambda
                    arguments[1] = lambdaExpr
                }
            }
        )

        // 3. Generate the getter body: return binding$delegate.getValue(this, binding$kprop)
        // This follows Kotlin's standard property delegate protocol.
        val getterThisParam = getter.parameters.first()
        getter.body = DeclarationIrBuilder(pluginContext, getter.symbol).irBlockBody {
            +irReturn(
                irCall(getValueFn).apply {
                    type = bindingType
                    // dispatch receiver: the delegate field value
                    dispatchReceiver = irGetField(irGet(getterThisParam), delegateField)
                    // thisRef parameter: the fragment instance
                    arguments[1] = irGet(getterThisParam)
                    // property parameter: the static KProperty field
                    arguments[2] = irGetField(null, kPropField)
                }
            )
        }

        return true
    }

    // Fallback: generates a direct binding getter without caching.
    // The generated code is equivalent to:
    //   get() = XxxBinding.bind(requireView())
    //
    // This approach has no lifecycle management — the binding is recreated on every access.
    // It's used when the VBPD library is not available on the classpath.
    private fun generateDirectBindingGetter(
        declaration: IrProperty,
        parentClass: IrClass,
    ) {
        val getter = declaration.getter ?: return
        val returnType = getter.returnType
        val bindingClass = returnType.classOrNull?.owner ?: return

        // Resolve XxxBinding.bind(View) static function.
        val bindFn = bindingClass.functions.firstOrNull {
            it.name.asString() == "bind" && regularParameterCount(it.parameters) == 1
        } ?: return

        // Resolve Fragment.requireView() function.
        val fragmentClass = pluginContext.referenceClass(FRAGMENT_CLASS_ID)!!
        val requireViewFn = fragmentClass.owner.functions.first {
            it.name.asString() == "requireView" && regularParameterCount(it.parameters) == 0
        }

        val thisParam = getter.parameters.first()

        // Generate getter body: return XxxBinding.bind(this.requireView())
        getter.body = DeclarationIrBuilder(pluginContext, getter.symbol).irBlockBody {
            +irReturn(
                irCall(bindFn).apply {
                    // Call requireView() on the fragment to get the root view.
                    arguments[0] = irCall(requireViewFn).apply {
                        dispatchReceiver = irGet(thisParam)
                    }
                }
            )
        }
    }
}
