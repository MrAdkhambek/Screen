// Package declaration for the FIR phase of the Screen compiler plugin.
package com.adkhambek.screen.compiler.fir

// Import FirSession which represents the current compilation session with access to all FIR services.
import org.jetbrains.kotlin.fir.FirSession
// Import FirDeclarationOrigin to check if a declaration was generated by a plugin.
import org.jetbrains.kotlin.fir.declarations.FirDeclarationOrigin
// Import findArgumentByName to extract named arguments from annotation expressions.
import org.jetbrains.kotlin.fir.declarations.findArgumentByName
// Import getAnnotationByClassId to look up annotations on symbols.
import org.jetbrains.kotlin.fir.declarations.getAnnotationByClassId
// Import FirClassReferenceExpression for resolved class references in annotations.
import org.jetbrains.kotlin.fir.expressions.FirClassReferenceExpression
// Import FirGetClassCall which represents ::class expressions.
import org.jetbrains.kotlin.fir.expressions.FirGetClassCall
// Import FirPropertyAccessExpression for unresolved property accesses.
import org.jetbrains.kotlin.fir.expressions.FirPropertyAccessExpression
// Import FirResolvedQualifier for fully resolved qualified names.
import org.jetbrains.kotlin.fir.expressions.FirResolvedQualifier
// Import coneTypeOrNull to extract ConeKotlinType from type references.
import org.jetbrains.kotlin.fir.types.coneTypeOrNull
// Import FirResolvePhase to specify minimum resolution phases.
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
// Import lazyResolveToPhase to trigger lazy resolution.
import org.jetbrains.kotlin.fir.symbols.lazyResolveToPhase
// Import origin to check the origin of a FIR declaration.
import org.jetbrains.kotlin.fir.declarations.origin
// Import classId utility for extracting classId from declaration utils.
import org.jetbrains.kotlin.fir.declarations.utils.classId
// Import isCompanion to check if a class symbol represents a companion object.
import org.jetbrains.kotlin.fir.declarations.utils.isCompanion
// Import Visibilities to set property/function visibility (e.g., Private, Public).
import org.jetbrains.kotlin.descriptors.Visibilities
// Import FirLiteralExpression for reading literal values from annotation arguments.
import org.jetbrains.kotlin.fir.expressions.FirLiteralExpression
// Import buildLiteralExpression to create literal expression nodes for default parameter values.
import org.jetbrains.kotlin.fir.expressions.builder.buildLiteralExpression
// Import ConstantValueKind to specify the type of literal constants (Null, Boolean, String, etc.).
import org.jetbrains.kotlin.types.ConstantValueKind
// Import DeclarationGenerationContext which provides contextual information during declaration generation.
import org.jetbrains.kotlin.fir.extensions.DeclarationGenerationContext
// Import FirDeclarationGenerationExtension, the base class for plugins that generate new declarations.
import org.jetbrains.kotlin.fir.extensions.FirDeclarationGenerationExtension
// Import FirDeclarationPredicateRegistrar used to register predicates that filter which classes trigger generation.
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
// Import predicateBasedProvider for fast predicate-based lookups on class symbols.
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
// Import createCompanionObject helper to create a companion object declaration.
import org.jetbrains.kotlin.fir.plugin.createCompanionObject
// Import createConeType to construct ConeKotlinType from a ClassId.
import org.jetbrains.kotlin.fir.plugin.createConeType
// Import createDefaultPrivateConstructor to create a private constructor for the generated companion.
import org.jetbrains.kotlin.fir.plugin.createDefaultPrivateConstructor
// Import createMemberFunction to create a function declaration on a class.
import org.jetbrains.kotlin.fir.plugin.createMemberFunction
// Import createMemberProperty to create a property declaration on a class.
import org.jetbrains.kotlin.fir.plugin.createMemberProperty
// Import symbolProvider to look up symbols by ClassId from the session.
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
// Import SymbolInternals opt-in for accessing internal symbol properties.
import org.jetbrains.kotlin.fir.symbols.SymbolInternals
// Import FirClassLikeSymbol which is the base symbol type for classes and type aliases.
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
// Import FirClassSymbol which represents a class symbol (regular class, object, etc.).
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
// Import FirConstructorSymbol which represents a constructor symbol.
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
// Import FirNamedFunctionSymbol which represents a named function symbol.
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
// Import FirPropertySymbol which represents a property symbol.
import org.jetbrains.kotlin.fir.symbols.impl.FirPropertySymbol
// Import FirRegularClassSymbol for regular (non-anonymous) class symbols.
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
// Import classId extension to extract ClassId from a ConeKotlinType.
import org.jetbrains.kotlin.fir.types.classId
// Import coneType extension to get the ConeKotlinType from a FirTypeRef.
import org.jetbrains.kotlin.fir.types.coneType
// Import CallableId which uniquely identifies a callable (function/property) by package, class, and name.
import org.jetbrains.kotlin.name.CallableId
// Import ClassId which uniquely identifies a class by package and relative class name.
import org.jetbrains.kotlin.name.ClassId
// Import FqName representing a fully qualified dotted name.
import org.jetbrains.kotlin.name.FqName
// Import Name representing a simple (non-qualified) identifier.
import org.jetbrains.kotlin.name.Name
// Import SpecialNames which provides well-known special names like DEFAULT_NAME_FOR_COMPANION_OBJECT.
import org.jetbrains.kotlin.name.SpecialNames
// Import StandardClassIds which provides well-known ClassIds for standard library types (Unit, String, etc.).
import org.jetbrains.kotlin.name.StandardClassIds

// ClassId for the Cicerone FragmentScreen class used in createScreen() return type.
// FragmentScreen is the navigation target abstraction in the Cicerone library.
private val FRAGMENT_SCREEN_CLASS_ID = ClassId(
    FqName("com.github.terrakok.cicerone.androidx"),
    Name.identifier("FragmentScreen"),
)

// ClassId for the @Screen annotation used to identify annotated classes.
private val SCREEN_CLASS_ID = ClassId(
    FqName("com.adkhambek.screen"),
    Name.identifier("Screen"),
)

// Data class holding the parsed @Screen annotation arguments.
// argClassId: the ClassId of the arg type (null if arg=Unit::class or not specified).
// isNullable: whether the arg is nullable (from @Screen(isNullable = true)).
data class ScreenArgs(
    val argClassId: ClassId?,
    val isNullable: Boolean,
)

// Core FIR declaration generation extension for the Screen compiler plugin.
// This extension is responsible for generating new declarations (symbols) in the FIR phase:
//   1. Companion object — if the @Screen class doesn't have one
//   2. KEY property — const val KEY: String on the companion object
//   3. arg property — private val arg: ArgType on the fragment class (if arg is specified)
//   4. createScreen() function — factory function on the companion (if Cicerone is available)
// These declarations are "stubs" without bodies; actual bodies are generated in the IR phase.
class ScreenFirDeclarationGenerationExtension(
    session: FirSession,
) : FirDeclarationGenerationExtension(session) {

    // Reads the @Screen annotation arguments from a class symbol.
    // Returns a ScreenArgs data class containing the parsed arg ClassId and nullability.
    // Uses SymbolInternals to access the annotation's raw argument list.
    @OptIn(SymbolInternals::class)
    private fun FirClassSymbol<*>.readScreenArgs(): ScreenArgs {
        // Ensure the annotation arguments are resolved before reading them.
        lazyResolveToPhase(FirResolvePhase.ANNOTATION_ARGUMENTS)
        // Look up the @Screen annotation on this class symbol.
        val annotation = this.getAnnotationByClassId(SCREEN_CLASS_ID, session)
            ?: return ScreenArgs(null, false)

        // Read the `arg` KClass parameter from the annotation.
        // findArgumentByName works both before and after annotation argument resolution
        // by falling back to the raw argumentList on FirAnnotationCall.
        var argClassId: ClassId? = null
        val argExpr = annotation.findArgumentByName(Name.identifier("arg"), returnFirstWhenNotFound = false)
        if (argExpr != null) {
            // The arg expression is a ::class call (e.g., MyArg::class).
            val getClassCall = argExpr as? FirGetClassCall
            if (getClassCall != null) {
                val argument = getClassCall.argument
                // Handle different FIR expression types depending on the resolution stage.
                when (argument) {
                    // After resolution: fully resolved qualifier with known classId.
                    is FirResolvedQualifier -> argClassId = argument.classId
                    // Resolved class reference: extract classId from the type reference.
                    is FirClassReferenceExpression -> argClassId = argument.classTypeRef.coneTypeOrNull?.classId
                    // Before resolution: simple property access expression.
                    // Construct a candidate ClassId in the same package and verify it exists.
                    is FirPropertyAccessExpression -> {
                        val simpleName = argument.calleeReference.name
                        val candidateClassId = ClassId(this.classId.packageFqName, simpleName)
                        if (session.symbolProvider.getClassLikeSymbolByClassId(candidateClassId) != null) {
                            argClassId = candidateClassId
                        }
                    }
                    else -> {}
                }
            }
        }
        // Treat Unit as "no argument specified".
        if (argClassId == StandardClassIds.Unit) {
            argClassId = null
        }

        // Read the `isNullable` boolean literal parameter from the annotation.
        var isNullableArg = false
        val isNullableExpr = annotation.findArgumentByName(Name.identifier("isNullable"), returnFirstWhenNotFound = false)
        if (isNullableExpr is FirLiteralExpression) {
            isNullableArg = isNullableExpr.value as? Boolean ?: false
        }

        return ScreenArgs(argClassId, isNullableArg)
    }

    // Checks whether the Cicerone FragmentScreen class is available on the compilation classpath.
    // If not available, the createScreen() function will not be generated.
    private fun isFragmentScreenAvailable(): Boolean {
        return session.symbolProvider.getClassLikeSymbolByClassId(FRAGMENT_SCREEN_CLASS_ID) != null
    }

    // Returns the set of nested classifier names that should be generated for a @Screen class.
    // If the class is annotated with @Screen and doesn't have a companion object,
    // returns a set containing the default companion object name so one will be generated.
    @OptIn(SymbolInternals::class)
    override fun getNestedClassifiersNames(
        classSymbol: FirClassSymbol<*>,
        context: DeclarationGenerationContext.Nested,
    ): Set<Name> {
        if (classSymbol.hasScreenAnnotation()) {
            // Only generate a companion object for regular classes (not anonymous/local classes).
            val regularSymbol = classSymbol as? FirRegularClassSymbol ?: return emptySet()
            // Only generate if the class doesn't already have a companion object.
            if (regularSymbol.companionObjectSymbol == null) {
                return setOf(SpecialNames.DEFAULT_NAME_FOR_COMPANION_OBJECT)
            }
        }
        return emptySet()
    }

    // Generates the companion object declaration for @Screen classes that lack one.
    // Returns the symbol of the newly created companion object, or null if generation is not needed.
    @OptIn(SymbolInternals::class)
    override fun generateNestedClassLikeDeclaration(
        owner: FirClassSymbol<*>,
        name: Name,
        context: DeclarationGenerationContext.Nested,
    ): FirClassLikeSymbol<*>? {
        // Only handle requests for the default companion object name.
        if (name != SpecialNames.DEFAULT_NAME_FOR_COMPANION_OBJECT) return null
        // Only generate for @Screen-annotated classes.
        if (!owner.hasScreenAnnotation()) return null

        // Create the companion object using the plugin helper, tagged with ScreenDeclarationKey.
        val companionObject = createCompanionObject(owner, ScreenDeclarationKey)
        return companionObject.symbol
    }

    // Returns the set of callable names (properties/functions) to be generated for a class.
    // For the @Screen class itself: generates "arg" property (if arg is specified).
    // For the companion object: generates "KEY" property, "createScreen()" function, and constructor.
    override fun getCallableNamesForClass(
        classSymbol: FirClassSymbol<*>,
        context: DeclarationGenerationContext.Member,
    ): Set<Name> {
        // For the @Screen class itself (not companion): generate "arg" property.
        if (!classSymbol.isCompanion) {
            if (classSymbol.hasScreenAnnotation()) {
                return setOf(Name.identifier("arg"))
            }
            return emptySet()
        }
        // For the companion object: check if the outer class has @Screen.
        val outerClassId = classSymbol.classId.outerClassId ?: return emptySet()
        val outerSymbol = session.symbolProvider.getClassLikeSymbolByClassId(outerClassId)
            as? FirClassSymbol<*> ?: return emptySet()
        if (!outerSymbol.hasScreenAnnotation()) return emptySet()

        // Always generate KEY on the companion.
        val result = mutableSetOf(
            Name.identifier("KEY"),
        )

        // Generate createScreen() only if Cicerone's FragmentScreen is on the classpath.
        if (isFragmentScreenAvailable()) {
            result += Name.identifier("createScreen")
        }

        // If the companion was generated by this plugin (not user-defined),
        // we also need to generate its constructor.
        if (classSymbol.origin is FirDeclarationOrigin.Plugin) {
            result += SpecialNames.INIT
        }

        return result
    }

    // Generates constructors for the companion object.
    // Only called for plugin-generated companion objects that need a private constructor.
    override fun generateConstructors(
        context: DeclarationGenerationContext.Member,
    ): List<FirConstructorSymbol> {
        val owner = context.owner
        // Only generate constructors for companion objects.
        if (!owner.isCompanion) return emptyList()
        // Only generate for plugin-created companions (user-defined companions already have constructors).
        if (owner.origin !is FirDeclarationOrigin.Plugin) return emptyList()

        // Verify the outer class has @Screen annotation.
        val outerClassId = owner.classId.outerClassId ?: return emptyList()
        val outerSymbol = session.symbolProvider.getClassLikeSymbolByClassId(outerClassId)
            as? FirClassSymbol<*> ?: return emptyList()
        if (!outerSymbol.hasScreenAnnotation()) return emptyList()

        // Create a private constructor for the companion object.
        val constructor = createDefaultPrivateConstructor(owner, ScreenDeclarationKey)
        return listOf(constructor.symbol)
    }

    // Generates property declarations (KEY and arg) for @Screen classes.
    // For "arg": generates a private val on the fragment class that reads from the Bundle.
    // For "KEY": generates a const val on the companion object with the FQN as its value.
    override fun generateProperties(
        callableId: CallableId,
        context: DeclarationGenerationContext.Member?,
    ): List<FirPropertySymbol> {
        val name = callableId.callableName.asString()

        // Handle "arg" property generation on the fragment class itself.
        if (name == "arg") {
            // Resolve the owning class symbol.
            val owner = context?.owner ?: run {
                val className = callableId.className ?: return emptyList()
                val classId = ClassId(callableId.packageName, className, false)
                session.symbolProvider.getClassLikeSymbolByClassId(classId) as? FirClassSymbol<*>
            } ?: return emptyList()

            // arg is only generated on the fragment class, not on the companion.
            if (owner.isCompanion) return emptyList()
            if (!owner.hasScreenAnnotation()) return emptyList()

            // Read the @Screen annotation to get the arg type and nullability.
            val componentUIArgs = owner.readScreenArgs()
            // Skip if no arg class is specified (or it's Unit).
            val argClassId = componentUIArgs.argClassId ?: return emptyList()
            // Create the ConeKotlinType for the arg, respecting the nullable flag.
            val argType = argClassId.createConeType(session, nullable = componentUIArgs.isNullable)

            // Create the arg property: private val arg: ArgType (or ArgType?).
            // hasBackingField=false because the getter reads from Bundle, not a stored field.
            val property = createMemberProperty(
                owner,
                ScreenDeclarationKey,
                callableId.callableName,
                argType,
                isVal = true,
                hasBackingField = false,
            ) {
                visibility = Visibilities.Private
            }

            return listOf(property.symbol)
        }

        // Handle "KEY" property generation on the companion object.
        if (name != "KEY") return emptyList()

        // Resolve the owning class symbol (should be the companion object).
        val owner = context?.owner ?: run {
            val className = callableId.className ?: return emptyList()
            val classId = ClassId(callableId.packageName, className, false)
            session.symbolProvider.getClassLikeSymbolByClassId(classId) as? FirClassSymbol<*>
        } ?: return emptyList()

        // KEY is only generated on companion objects, not on the fragment class itself.
        if (!owner.isCompanion) return emptyList()
        // Verify the outer class has @Screen annotation.
        val outerClassId = owner.classId.outerClassId ?: return emptyList()
        val outerSymbol = session.symbolProvider.getClassLikeSymbolByClassId(outerClassId)
            as? FirClassSymbol<*> ?: return emptyList()
        if (!outerSymbol.hasScreenAnnotation()) return emptyList()

        // Get the String type for the KEY property.
        val stringType = session.builtinTypes.stringType.coneType

        // Create the KEY property: const val KEY: String.
        // hasBackingField=true because const vals require a backing field for the constant value.
        // The status block sets isConst=true so Kotlin treats it as a compile-time constant.
        val property = createMemberProperty(
            owner,
            ScreenDeclarationKey,
            callableId.callableName,
            stringType,
            isVal = true,
            hasBackingField = true,
        ) {
            status { isConst = true }
        }

        return listOf(property.symbol)
    }

    // Generates the createScreen() function declaration on the companion object.
    // This function creates a Cicerone FragmentScreen that navigates to this fragment.
    // Parameters:
    //   - arg: ArgType (if @Screen specifies an arg; with default null if isNullable)
    //   - key: String? = null (navigation key override)
    //   - clearContainer: Boolean = true (whether to clear the container before navigation)
    @OptIn(SymbolInternals::class)
    override fun generateFunctions(
        callableId: CallableId,
        context: DeclarationGenerationContext.Member?,
    ): List<FirNamedFunctionSymbol> {
        // Only handle createScreen function requests.
        if (callableId.callableName.asString() != "createScreen") return emptyList()

        // Resolve the owning class symbol (should be the companion object).
        val owner = context?.owner ?: run {
            val className = callableId.className ?: return emptyList()
            val classId = ClassId(callableId.packageName, className, false)
            session.symbolProvider.getClassLikeSymbolByClassId(classId) as? FirClassSymbol<*>
        } ?: return emptyList()

        // createScreen is only generated on companion objects.
        if (!owner.isCompanion) return emptyList()
        // Verify the outer class has @Screen annotation.
        val outerClassId = owner.classId.outerClassId ?: return emptyList()
        val outerSymbol = session.symbolProvider.getClassLikeSymbolByClassId(outerClassId)
            as? FirClassSymbol<*> ?: return emptyList()
        if (!outerSymbol.hasScreenAnnotation()) return emptyList()

        // The return type is FragmentScreen from the Cicerone library.
        val fragmentScreenType = FRAGMENT_SCREEN_CLASS_ID.createConeType(session)
        // Read the @Screen annotation arguments for the outer class.
        val componentUIArgs = outerSymbol.readScreenArgs()

        // Create nullable String and Boolean types for the key and clearContainer parameters.
        val nullableStringType = StandardClassIds.String.createConeType(session, nullable = true)
        val booleanType = session.builtinTypes.booleanType.coneType

        // Create the function declaration with its parameters.
        val fn = createMemberFunction(
            owner,
            ScreenDeclarationKey,
            callableId.callableName,
            fragmentScreenType,
        ) {
            // Add the arg parameter if an arg class is specified.
            if (componentUIArgs.argClassId != null) {
                val argType = componentUIArgs.argClassId.createConeType(
                    session,
                    nullable = componentUIArgs.isNullable,
                )
                // The arg parameter has a default value only if it's nullable (defaulting to null).
                valueParameter(
                    Name.identifier("arg"),
                    argType,
                    hasDefaultValue = componentUIArgs.isNullable,
                )
            }
            // key parameter: String? = null (allows overriding the navigation key).
            valueParameter(Name.identifier("key"), nullableStringType, hasDefaultValue = true)
            // clearContainer parameter: Boolean = true (Cicerone navigation option).
            valueParameter(Name.identifier("clearContainer"), booleanType, hasDefaultValue = true)
        }

        // Replace FirExpressionStub default values with actual literal expressions.
        // The createMemberFunction helper creates stubs for default values, but we need
        // actual FIR literal expressions for the IR phase to process correctly.
        val nullLiteral = buildLiteralExpression(null, ConstantValueKind.Null, null, setType = true)
        val trueLiteral = buildLiteralExpression(null, ConstantValueKind.Boolean, true, setType = true)
        for (param in fn.valueParameters) {
            when (param.name.asString()) {
                // Set the default value for the arg parameter to null (only if nullable).
                "arg" -> if (componentUIArgs.isNullable) {
                    param.replaceDefaultValue(buildLiteralExpression(null, ConstantValueKind.Null, null, setType = true))
                }
                // Set the default value for key to null.
                "key" -> param.replaceDefaultValue(nullLiteral)
                // Set the default value for clearContainer to true.
                "clearContainer" -> param.replaceDefaultValue(trueLiteral)
            }
        }

        return listOf(fn.symbol)
    }

    // Helper to check if a class symbol has the @Screen annotation.
    // Uses the predicate-based provider for efficient O(1) lookups after initial caching.
    private fun FirClassSymbol<*>.hasScreenAnnotation(): Boolean {
        return session.predicateBasedProvider.matches(screenPredicate, this)
    }

    // Register the screen predicate so the FIR infrastructure knows which classes to watch.
    // This predicate filters classes annotated with @com.adkhambek.screen.Screen.
    override fun FirDeclarationPredicateRegistrar.registerPredicates() {
        register(screenPredicate)
    }
}
