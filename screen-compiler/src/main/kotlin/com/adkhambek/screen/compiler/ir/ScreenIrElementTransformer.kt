// Suppress INVISIBLE_MEMBER warnings for accessing internal Kotlin compiler APIs.
@file:Suppress("INVISIBLE_MEMBER")

// Package declaration for the IR phase of the Screen compiler plugin.
package com.adkhambek.screen.compiler.ir

// Import ScreenDeclarationKey to identify declarations generated by this plugin.
import com.adkhambek.screen.compiler.fir.ScreenDeclarationKey
// Import IrPluginContext which provides access to IR type system, symbols, and factory.
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
// Import DeclarationIrBuilder which provides a DSL for building IR expression trees.
import org.jetbrains.kotlin.backend.common.lower.DeclarationIrBuilder
// Import DescriptorVisibilities for setting visibility of generated IR declarations.
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
// Import Modality for setting modality (FINAL, OPEN, ABSTRACT) of generated IR declarations.
import org.jetbrains.kotlin.descriptors.Modality
// Import IrStatement which is the base type for all IR statements.
import org.jetbrains.kotlin.ir.IrStatement
// Import addValueParameter for adding parameters to IR function declarations.
import org.jetbrains.kotlin.ir.builders.declarations.addValueParameter
// Import buildFun for building IR function declarations.
import org.jetbrains.kotlin.ir.builders.declarations.buildFun
// Import irBlockBody for creating an IR block body (sequence of statements).
import org.jetbrains.kotlin.ir.builders.irBlockBody
// Import irCall for creating IR function call expressions.
import org.jetbrains.kotlin.ir.builders.irCall
// Import irCallConstructor for creating IR constructor call expressions.
import org.jetbrains.kotlin.ir.builders.irCallConstructor
// Import irGet for creating IR expressions that read a variable/parameter.
import org.jetbrains.kotlin.ir.builders.irGet
// Import irGetField for creating IR expressions that read a field.
import org.jetbrains.kotlin.ir.builders.irGetField
// Import irGetObjectValue for creating IR expressions that reference a singleton object.
import org.jetbrains.kotlin.ir.builders.irGetObjectValue
// Import irInt for creating IR integer constant expressions.
import org.jetbrains.kotlin.ir.builders.irInt
// Import irReturn for creating IR return statements.
import org.jetbrains.kotlin.ir.builders.irReturn
// Import irSamConversion for creating IR SAM (Single Abstract Method) conversion expressions.
import org.jetbrains.kotlin.ir.builders.irSamConversion
// Import irString for creating IR string constant expressions.
import org.jetbrains.kotlin.ir.builders.irString
// Import irTemporary for creating IR temporary variable declarations.
import org.jetbrains.kotlin.ir.builders.irTemporary
// Import IrClass which represents a class in the IR tree.
import org.jetbrains.kotlin.ir.declarations.IrClass
// Import IrDeclarationOrigin for checking and setting the origin of IR declarations.
import org.jetbrains.kotlin.ir.declarations.IrDeclarationOrigin
// Import IrParameterKind to distinguish between different parameter types (regular, extension, dispatch).
import org.jetbrains.kotlin.ir.declarations.IrParameterKind
// Import IrProperty which represents a property in the IR tree.
import org.jetbrains.kotlin.ir.declarations.IrProperty
// Import IrSimpleFunction which represents a named function in the IR tree.
import org.jetbrains.kotlin.ir.declarations.IrSimpleFunction
// Import IrStatementOrigin for marking the origin of IR statements (e.g., LAMBDA).
import org.jetbrains.kotlin.ir.expressions.IrStatementOrigin
// Import IrConstImpl for creating IR constant expression nodes (string, int, boolean, null).
import org.jetbrains.kotlin.ir.expressions.impl.IrConstImpl
// Import IrFunctionExpressionImpl for creating IR function expression (lambda) nodes.
import org.jetbrains.kotlin.ir.expressions.impl.IrFunctionExpressionImpl
// Import UnsafeDuringIrConstructionAPI opt-in required for accessing IR symbols during construction.
import org.jetbrains.kotlin.ir.symbols.UnsafeDuringIrConstructionAPI
// Import classOrNull to safely get the IrClassSymbol from an IrType.
import org.jetbrains.kotlin.ir.types.classOrNull
// Import isInt to check if an IrType is kotlin.Int.
import org.jetbrains.kotlin.ir.types.isInt
// Import typeWith to create a parameterized type (e.g., Function1<A, B>).
import org.jetbrains.kotlin.ir.types.typeWith
// Import companionObject to get the companion object of an IR class.
import org.jetbrains.kotlin.ir.util.companionObject
// Import constructors to iterate over constructors of an IR class.
import org.jetbrains.kotlin.ir.util.constructors
// Import defaultType to get the non-parameterized type of an IR class.
import org.jetbrains.kotlin.ir.util.defaultType
// Import functions to iterate over functions of an IR class.
import org.jetbrains.kotlin.ir.util.functions
// Import isNullable to check if an IrType is nullable.
import org.jetbrains.kotlin.ir.util.isNullable
// Import kotlinFqName to get the fully qualified name of an IR declaration.
import org.jetbrains.kotlin.ir.util.kotlinFqName
// Import parentClassOrNull to get the parent class of an IR declaration.
import org.jetbrains.kotlin.ir.util.parentClassOrNull
// Import properties to iterate over properties of an IR class.
import org.jetbrains.kotlin.ir.util.properties
// Import IrElementTransformerVoid which visits and optionally transforms IR elements.
import org.jetbrains.kotlin.ir.visitors.IrElementTransformerVoid
// Import CallableId for looking up functions by their fully qualified callable identifier.
import org.jetbrains.kotlin.name.CallableId
// Import ClassId for looking up classes by their package and class name.
import org.jetbrains.kotlin.name.ClassId
// Import FqName for creating fully qualified names.
import org.jetbrains.kotlin.name.FqName
// Import Name for creating simple identifiers.
import org.jetbrains.kotlin.name.Name

// ClassId for Cicerone's FragmentScreen class — the return type of createScreen().
private val FRAGMENT_SCREEN_CLASS_ID = ClassId(
    FqName("com.github.terrakok.cicerone.androidx"),
    Name.identifier("FragmentScreen"),
)
// ClassId for Cicerone's Creator interface — the SAM interface used in FragmentScreen.invoke().
private val CREATOR_CLASS_ID = ClassId(
    FqName("com.github.terrakok.cicerone.androidx"),
    Name.identifier("Creator"),
)
// ClassId for AndroidX FragmentFactory — used to instantiate fragments in the creator lambda.
private val FRAGMENT_FACTORY_CLASS_ID = ClassId(
    FqName("androidx.fragment.app"),
    Name.identifier("FragmentFactory"),
)
// ClassId for AndroidX Fragment — the base class for all fragments.
private val FRAGMENT_CLASS_ID = ClassId(
    FqName("androidx.fragment.app"),
    Name.identifier("Fragment"),
)
// ClassId for Android Bundle — used for passing arguments to fragments.
private val BUNDLE_CLASS_ID = ClassId(
    FqName("android.os"),
    Name.identifier("Bundle"),
)
// ClassId for AndroidX BundleCompat — provides getParcelable() with class parameter.
private val BUNDLE_COMPAT_CLASS_ID = ClassId(
    FqName("androidx.core.os"),
    Name.identifier("BundleCompat"),
)
// ClassId for java.lang.Class — used for Class.forName() and getClassLoader() calls.
private val JAVA_CLASS_ID = ClassId(
    FqName("java.lang"),
    Name.identifier("Class"),
)

// Utility function to count only regular parameters (excluding dispatch/extension receivers).
// This is needed because IR parameters include this/extension receivers in the same list.
private fun regularParameterCount(params: List<org.jetbrains.kotlin.ir.declarations.IrValueParameter>): Int =
    params.count { it.kind == IrParameterKind.Regular }

// IR element transformer that generates method bodies for declarations created by the Screen plugin.
// This transformer visits all IR properties and functions, checks if they were generated by
// ScreenDeclarationKey, and fills in their bodies:
//   - KEY property: sets the backing field initializer to the FQN string constant
//   - arg property: generates a getter that reads from Fragment.getArguments() via BundleCompat
//   - createScreen() function: generates a body that creates a FragmentScreen with a Creator lambda
// Opt into UnsafeDuringIrConstructionAPI because we access IR symbols during transformation.
@OptIn(UnsafeDuringIrConstructionAPI::class)
class ScreenIrElementTransformer(
    private val pluginContext: IrPluginContext,
) : IrElementTransformerVoid() {

    // Visits property declarations and generates bodies for plugin-generated properties.
    // Handles two properties:
    //   1. "arg" — generates a getter that reads from the Fragment's Bundle
    //   2. "KEY" — sets the backing field initializer to the outer class's FQN
    override fun visitProperty(declaration: IrProperty): IrStatement {
        // Check if this property was generated by the Screen plugin.
        val origin = declaration.origin as? IrDeclarationOrigin.GeneratedByPlugin
            ?: return super.visitProperty(declaration)
        if (origin.pluginKey != ScreenDeclarationKey) return super.visitProperty(declaration)

        // Get the parent class of this property.
        val parentClass = declaration.parentClassOrNull ?: return super.visitProperty(declaration)

        // Handle "arg" property: generate a getter that reads from the Fragment's Bundle.
        if (declaration.name.asString() == "arg") {
            generateArgGetter(declaration, parentClass)
            // Mark the getter origin as DEFINED so that JvmPropertiesLowering doesn't replace
            // getter calls with direct field access. Without this, the JVM backend would try to
            // read a backing field (which doesn't exist) instead of calling our custom getter.
            declaration.getter?.origin = IrDeclarationOrigin.DEFINED
            return declaration
        }

        // Handle "KEY" property on the companion object.
        if (declaration.name.asString() != "KEY") return super.visitProperty(declaration)
        // Get the outer class (the @Screen-annotated fragment class) from the companion.
        val outerClass = parentClass.parentClassOrNull ?: return super.visitProperty(declaration)
        // The KEY value is the fully qualified name of the outer class.
        val value = outerClass.kotlinFqName.asString()

        // Set the backing field initializer to the FQN string constant.
        val backingField = declaration.backingField ?: return super.visitProperty(declaration)
        val stringConst = IrConstImpl.string(
            backingField.startOffset,
            backingField.endOffset,
            pluginContext.irBuiltIns.stringType,
            value,
        )
        backingField.initializer = pluginContext.irFactory.createExpressionBody(
            backingField.startOffset,
            backingField.endOffset,
            stringConst,
        )

        return declaration
    }

    // Generates the getter body for the "arg" property.
    // The generated code is equivalent to:
    //   get() {
    //       val arguments = requireNotNull(this.getArguments())
    //       val argClass = Class.forName("com.example.ArgType")
    //       val result = BundleCompat.getParcelable(arguments, "com.example.MyFragment", argClass)
    //       return requireNotNull(result)  // or just return result if nullable
    //   }
    private fun generateArgGetter(declaration: IrProperty, parentClass: IrClass) {
        val getter = declaration.getter ?: return
        val returnType = getter.returnType
        // Check if the return type is nullable (from @Screen(isNullable = true)).
        val isNullable = returnType.isNullable()

        // Get the FQN of the arg class for Class.forName() and the parent class FQN for the Bundle key.
        val argClassFqn = returnType.classOrNull!!.owner.kotlinFqName.asString()
        val argKeyValue = parentClass.kotlinFqName.asString()

        // Resolve Fragment.getArguments() function symbol.
        val fragmentClass = pluginContext.referenceClass(FRAGMENT_CLASS_ID)!!
        val getArgumentsFn = fragmentClass.owner.functions.first {
            it.name.asString() == "getArguments"
        }

        // Resolve kotlin.requireNotNull(T?): T — the 1-parameter overload.
        // Used to assert non-null on the Bundle and the extracted Parcelable.
        val requireNotNullFn = pluginContext.referenceFunctions(
            CallableId(FqName("kotlin"), Name.identifier("requireNotNull"))
        ).first {
            it.owner.parameters.count { p -> p.kind == IrParameterKind.Regular } == 1
        }

        // Resolve BundleCompat.getParcelable(Bundle, String, Class) — the 3-parameter overload.
        // This is the AndroidX-compatible way to read Parcelable objects from a Bundle.
        val bundleCompatClass = pluginContext.referenceClass(BUNDLE_COMPAT_CLASS_ID)!!
        val getParcelableFn = bundleCompatClass.owner.functions.first {
            it.name.asString() == "getParcelable" && regularParameterCount(it.parameters) == 3
        }

        // Resolve Class.forName(String) to get the java.lang.Class object for the arg type.
        val javaLangClass = pluginContext.referenceClass(JAVA_CLASS_ID)!!
        val forNameFn = javaLangClass.owner.functions.first {
            it.name.asString() == "forName" && regularParameterCount(it.parameters) == 1
        }

        // Get the 'this' parameter for dispatching method calls on the fragment instance.
        val thisParam = getter.parameters.first()
        // Get the Bundle type for the requireNotNull call's type argument.
        val bundleType = pluginContext.referenceClass(BUNDLE_CLASS_ID)!!.owner.defaultType

        // Build the getter body using the DeclarationIrBuilder DSL.
        getter.body = DeclarationIrBuilder(pluginContext, getter.symbol).irBlockBody {
            // val arguments = requireNotNull(this.getArguments())
            // Calls Fragment.getArguments() and wraps it in requireNotNull() to assert non-null.
            val getArgumentsCall = irCall(getArgumentsFn).apply {
                dispatchReceiver = irGet(thisParam)
            }
            val argumentsVar = irTemporary(
                irCall(requireNotNullFn).apply {
                    typeArguments[0] = bundleType
                    type = bundleType
                    arguments[0] = getArgumentsCall
                },
                nameHint = "arguments",
            )

            // val argClass = Class.forName("com.example.Arg")
            // Gets the java.lang.Class object for the arg type using its FQN.
            val argClassVar = irTemporary(
                irCall(forNameFn).apply {
                    arguments[0] = irString(argClassFqn)
                },
                nameHint = "argClass",
            )

            // BundleCompat.getParcelable(arguments, KEY_VALUE, argClass)
            // Uses the parent class FQN as the key (matching what createScreen() uses for putParcelable).
            val getParcelableCall = irCall(getParcelableFn).apply {
                arguments[0] = irGet(argumentsVar)
                arguments[1] = irString(argKeyValue)
                arguments[2] = irGet(argClassVar)
            }

            // If the arg is nullable, return the result directly (may be null).
            // If non-nullable, wrap in requireNotNull() to ensure a non-null return.
            if (isNullable) {
                +irReturn(getParcelableCall)
            } else {
                val resultVar = irTemporary(getParcelableCall, nameHint = "result")
                +irReturn(
                    irCall(requireNotNullFn).apply {
                        typeArguments[0] = returnType
                        type = returnType
                        arguments[0] = irGet(resultVar)
                    }
                )
            }
        }
    }

    // Visits function declarations and generates bodies for plugin-generated functions.
    // Currently only handles "createScreen()" — the factory function on the companion object.
    override fun visitSimpleFunction(declaration: IrSimpleFunction): IrStatement {
        // Check if this function was generated by the Screen plugin.
        val origin = declaration.origin as? IrDeclarationOrigin.GeneratedByPlugin
            ?: return super.visitSimpleFunction(declaration)
        if (origin.pluginKey != ScreenDeclarationKey) return super.visitSimpleFunction(declaration)
        // Only handle the createScreen function.
        if (declaration.name.asString() != "createScreen") return super.visitSimpleFunction(
            declaration
        )

        // Get the companion class (direct parent) and outer class (the @Screen fragment).
        val companionClass =
            declaration.parentClassOrNull ?: return super.visitSimpleFunction(declaration)
        val outerClass =
            companionClass.parentClassOrNull ?: return super.visitSimpleFunction(declaration)
        // Get the FQN of the outer class for use in Class.forName() and the KEY constant.
        val fqName = outerClass.kotlinFqName.asString()

        // Generate default values for the function parameters (arg=null, key=null, clearContainer=true).
        generateDefaultValues(declaration)
        // Generate the function body that creates and returns a FragmentScreen.
        generateCreateScreenBody(declaration, companionClass, fqName)

        return declaration
    }

    // Generates IR default value expressions for the createScreen() parameters.
    // FIR creates stub default values; this method replaces them with actual IR constants.
    private fun generateDefaultValues(declaration: IrSimpleFunction) {
        val s = declaration.startOffset
        val e = declaration.endOffset

        for (param in declaration.parameters) {
            when (param.name.asString()) {
                // arg: default to null if the parameter type is nullable.
                "arg" -> {
                    if (param.type.isNullable()) {
                        param.defaultValue = pluginContext.irFactory.createExpressionBody(
                            s, e, IrConstImpl.constNull(s, e, pluginContext.irBuiltIns.nothingNType)
                        )
                    }
                }
                // key: always defaults to null (String?).
                "key" -> {
                    param.defaultValue = pluginContext.irFactory.createExpressionBody(
                        s, e, IrConstImpl.constNull(s, e, pluginContext.irBuiltIns.nothingNType)
                    )
                }
                // clearContainer: defaults to true (Boolean).
                "clearContainer" -> {
                    param.defaultValue = pluginContext.irFactory.createExpressionBody(
                        s, e, IrConstImpl.boolean(s, e, pluginContext.irBuiltIns.booleanType, true)
                    )
                }
            }
        }
    }

    // Generates the body of the createScreen() function.
    // The generated code is equivalent to:
    //   fun createScreen(arg: ArgType?, key: String?, clearContainer: Boolean): FragmentScreen {
    //       return FragmentScreen(key, clearContainer) { factory ->
    //           val javaClass = Class.forName("com.example.MyFragment")
    //           val classLoader = javaClass.classLoader
    //           val fragment = factory.instantiate(classLoader, "com.example.MyFragment")
    //           val bundle = Bundle(1)
    //           bundle.putParcelable(KEY, arg)
    //           fragment.setArguments(bundle)
    //           fragment
    //       }
    //   }
    private fun generateCreateScreenBody(
        declaration: IrSimpleFunction,
        companionClass: IrClass,
        fqName: String,
    ) {
        // Resolve parameters by name.
        val argParam = declaration.parameters.firstOrNull { it.name.asString() == "arg" }
        val keyParam = declaration.parameters.first { it.name.asString() == "key" }
        val clearContainerParam =
            declaration.parameters.first { it.name.asString() == "clearContainer" }
        val hasArg = argParam != null

        // Resolve Cicerone symbols needed for the function body.
        // FragmentScreen class and its companion's invoke() function.
        val fragmentScreenClass = pluginContext.referenceClass(FRAGMENT_SCREEN_CLASS_ID)!!
        val fragmentScreenCompanion = fragmentScreenClass.owner.companionObject()!!
        // FragmentScreen.invoke(key, clearContainer, creator) — the 3-parameter overload.
        val invokeFunction = fragmentScreenCompanion.functions.first {
            it.name.asString() == "invoke" && regularParameterCount(it.parameters) == 3
        }

        // Creator is the SAM interface that provides a lambda for fragment instantiation.
        val creatorClass = pluginContext.referenceClass(CREATOR_CLASS_ID)!!
        // FragmentFactory is passed to the creator lambda to instantiate fragments.
        val fragmentFactoryClass = pluginContext.referenceClass(FRAGMENT_FACTORY_CLASS_ID)!!
        // Fragment is the return type of the creator lambda.
        val fragmentClass = pluginContext.referenceClass(FRAGMENT_CLASS_ID)!!

        val fragmentFactoryType = fragmentFactoryClass.owner.defaultType
        val fragmentType = fragmentClass.owner.defaultType

        // Resolve FragmentFactory.instantiate(ClassLoader, String) for creating fragment instances.
        val instantiateFn = fragmentFactoryClass.owner.functions.first {
            it.name.asString() == "instantiate" && regularParameterCount(it.parameters) == 2
        }

        // Resolve java.lang.Class.forName(String) and getClassLoader() for classloader access.
        val javaLangClass = pluginContext.referenceClass(JAVA_CLASS_ID)!!
        val forNameFn = javaLangClass.owner.functions.first {
            it.name.asString() == "forName" && regularParameterCount(it.parameters) == 1
        }
        val getClassLoaderFn = javaLangClass.owner.functions.first {
            it.name.asString() == "getClassLoader" && it.parameters.none { p -> p.kind == IrParameterKind.Regular }
        }

        // Build the Creator SAM type: Creator<FragmentFactory, Fragment>.
        val creatorType = creatorClass.typeWith(fragmentFactoryType, fragmentType)

        // Build the lambda function for the Creator SAM conversion.
        // This lambda takes a FragmentFactory and returns a Fragment.
        val lambdaFn = pluginContext.irFactory.buildFun {
            name = Name.special("<anonymous>")
            returnType = fragmentType
            origin = IrDeclarationOrigin.LOCAL_FUNCTION_FOR_LAMBDA
            visibility = DescriptorVisibilities.LOCAL
            modality = Modality.FINAL
        }.apply {
            // Set the parent to the createScreen function for proper scoping.
            parent = declaration
            // Add the factory parameter (FragmentFactory).
            val factoryParam = addValueParameter("factory", fragmentFactoryType)

            // Build the lambda body.
            body = DeclarationIrBuilder(pluginContext, symbol).irBlockBody {
                // val javaClass = Class.forName("com.example.MyFragment")
                // Gets the java.lang.Class for the fragment using its FQN.
                val javaClassVar = irTemporary(
                    irCall(forNameFn).apply {
                        arguments[0] = irString(fqName)
                    },
                    nameHint = "javaClass",
                )

                // val classLoader = javaClass.classLoader
                // Gets the ClassLoader for passing to FragmentFactory.instantiate().
                val classLoaderExpr = irCall(getClassLoaderFn).apply {
                    dispatchReceiver = irGet(javaClassVar)
                }
                val classLoaderVar = irTemporary(classLoaderExpr, nameHint = "classLoader")

                // val fragment = factory.instantiate(classLoader, "com.example.MyFragment")
                // Instantiates the fragment using FragmentFactory for proper dependency injection.
                val instantiateExpr = irCall(instantiateFn).apply {
                    dispatchReceiver = irGet(factoryParam)
                    arguments[1] = irGet(classLoaderVar)
                    arguments[2] = irString(fqName)
                }

                // If no arg is specified, return the fragment directly.
                if (!hasArg) {
                    +irReturn(instantiateExpr)
                } else {
                    // val fragment = factory.instantiate(...)
                    val fragmentVar = irTemporary(instantiateExpr, nameHint = "fragment")

                    // val bundle = Bundle(1)
                    // Create a new Bundle with initial capacity of 1 (for the single arg).
                    val bundleClass = pluginContext.referenceClass(BUNDLE_CLASS_ID)!!
                    val bundleConstructor = bundleClass.owner.constructors.first {
                        it.parameters.size == 1 && it.parameters[0].type.isInt()
                    }
                    val bundleVar = irTemporary(
                        irCallConstructor(bundleConstructor.symbol, emptyList()).apply {
                            arguments[0] = irInt(1)
                        },
                        nameHint = "bundle",
                    )

                    // bundle.putParcelable(KEY, arg)
                    // Put the arg into the bundle using the KEY constant as the key.
                    val putParcelableFn = bundleClass.owner.functions.first {
                        it.name.asString() == "putParcelable" && regularParameterCount(it.parameters) == 2
                    }
                    // Access the generated KEY property's backing field from the companion object.
                    val keyProperty = companionClass.properties.first {
                        it.name.asString() == "KEY"
                    }
                    +irCall(putParcelableFn).apply {
                        dispatchReceiver = irGet(bundleVar)
                        // Read KEY from the companion object's backing field.
                        arguments[1] = irGetField(
                            irGetObjectValue(
                                companionClass.defaultType,
                                companionClass.symbol,
                            ),
                            keyProperty.backingField!!,
                        )
                        // Pass the arg parameter value.
                        arguments[2] = irGet(argParam)
                    }

                    // fragment.setArguments(bundle)
                    // Attach the bundle to the fragment as its arguments.
                    val setArgumentsFn = fragmentClass.owner.functions.first {
                        it.name.asString() == "setArguments"
                    }
                    +irCall(setArgumentsFn).apply {
                        dispatchReceiver = irGet(fragmentVar)
                        arguments[1] = irGet(bundleVar)
                    }

                    // return fragment
                    +irReturn(irGet(fragmentVar))
                }
            }
        }

        // Build the function expression (lambda) for the SAM conversion.
        // This wraps the lambda function in an IrFunctionExpression node.
        val lambdaType = pluginContext.irBuiltIns.functionN(1).typeWith(fragmentFactoryType, fragmentType)
        val lambdaExpr = IrFunctionExpressionImpl(
            startOffset = declaration.startOffset,
            endOffset = declaration.endOffset,
            type = lambdaType,
            function = lambdaFn,
            origin = IrStatementOrigin.LAMBDA,
        )

        // Build the function body: return FragmentScreen(key, clearContainer, creator)
        // Uses irSamConversion to convert the lambda into the Creator SAM interface.
        declaration.body = DeclarationIrBuilder(pluginContext, declaration.symbol).irBlockBody {
            // Convert the lambda to a Creator<FragmentFactory, Fragment> SAM instance.
            val samExpr = irSamConversion(lambdaExpr, creatorType)

            // Call FragmentScreen.invoke(key, clearContainer, creator) and return the result.
            +irReturn(
                irCall(invokeFunction).apply {
                    // dispatch receiver is the FragmentScreen companion object.
                    dispatchReceiver = irGetObjectValue(
                        fragmentScreenCompanion.defaultType,
                        fragmentScreenCompanion.symbol,
                    )
                    // Pass the key, clearContainer, and SAM-converted creator.
                    arguments[1] = irGet(keyParam)
                    arguments[2] = irGet(clearContainerParam)
                    arguments[3] = samExpr
                }
            )
        }
    }
}
