// Package declaration for the Screen IDEA plugin module.
package com.adkhambek.screen.idea

// Import LocalInspectionTool, the base class for code inspections that operate on a single file.
import com.intellij.codeInspection.LocalInspectionTool
// Import ProblemsHolder which collects problems (warnings/errors) found during inspection.
import com.intellij.codeInspection.ProblemsHolder
// Import PsiElementVisitor, the base visitor interface for traversing PSI trees.
import com.intellij.psi.PsiElementVisitor
// Import analyze for Kotlin Analysis API operations.
import org.jetbrains.kotlin.analysis.api.analyze
// Import ClassId for identifying the @Screen annotation class.
import org.jetbrains.kotlin.name.ClassId
// Import FqName for fully qualified name representation.
import org.jetbrains.kotlin.name.FqName
// Import Name for simple identifier representation.
import org.jetbrains.kotlin.name.Name
// Import KtClassOrObject, the base PSI class for class and object declarations.
import org.jetbrains.kotlin.psi.KtClassOrObject
// Import KtObjectDeclaration which represents an object declaration (including companion objects).
import org.jetbrains.kotlin.psi.KtObjectDeclaration
// Import KtProperty which represents a property declaration in the PSI tree.
import org.jetbrains.kotlin.psi.KtProperty
// Import KtVisitorVoid, a Kotlin PSI visitor with void return type.
import org.jetbrains.kotlin.psi.KtVisitorVoid

// Code inspection that warns developers when they manually define a "KEY" property
// in the companion object of a @Screen-annotated class. Since the Screen compiler plugin
// automatically generates the KEY constant, a manual definition would conflict with it.
//
// Registered in plugin.xml as a localInspection with:
//   - shortName: "ScreenManualConstant"
//   - groupName: "Screen"
//   - level: WARNING
//   - enabledByDefault: true
class ScreenManualConstantInspection : LocalInspectionTool() {

    // ClassId for the @Screen annotation, used to verify the owner class is annotated.
    private val screenClassId = ClassId(
        FqName("com.adkhambek.screen"),
        Name.identifier("Screen"),
    )

    // Builds a PSI visitor that inspects property declarations for conflicting manual definitions.
    // The visitor traverses all properties in the file and checks if any match the pattern
    // of a manually defined KEY in a @Screen class's companion object.
    override fun buildVisitor(holder: ProblemsHolder, isOnTheFly: Boolean): PsiElementVisitor {
        return object : KtVisitorVoid() {
            // Called for each property declaration in the file.
            override fun visitProperty(property: KtProperty) {
                val name = property.name ?: return
                // Only check properties named "KEY".
                if (name != "KEY") return

                // Navigate up the PSI tree to verify this property is inside a companion object.
                // PSI tree: KtProperty -> KtClassBody -> KtObjectDeclaration (companion)
                val companion = property.parent?.parent as? KtObjectDeclaration ?: return
                if (!companion.isCompanion()) return
                // Navigate to the outer class to check for @Screen annotation.
                val ownerClass = companion.parent?.parent as? KtClassOrObject ?: return
                if (!hasScreenAnnotation(ownerClass)) return

                // Register a warning problem on the property's name identifier.
                // This shows a yellow warning highlight and message in the editor.
                holder.registerProblem(
                    property.nameIdentifier ?: property,
                    "'$name' is automatically generated by the Screen compiler plugin for @Screen classes. This manual definition will conflict with the generated constant.",
                )
            }
        }
    }

    // Checks whether a class or object has the @Screen annotation.
    // Uses the Kotlin Analysis API (analyze block) to inspect the symbol's annotations.
    private fun hasScreenAnnotation(classOrObject: KtClassOrObject): Boolean {
        analyze(classOrObject) {
            val symbol = classOrObject.symbol
            return symbol.annotations.any { it.classId == screenClassId }
        }
    }
}
