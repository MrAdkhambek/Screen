// Package declaration for the Screen IDEA plugin module.
package com.adkhambek.screen.idea

// Import AbstractDocumentationProvider, the base class for adding custom Quick Documentation popups.
import com.intellij.lang.documentation.AbstractDocumentationProvider
// Import PsiElement, the base class for all PSI (Program Structure Interface) tree nodes.
import com.intellij.psi.PsiElement
// Import analyze which provides a scope for Kotlin Analysis API operations.
import org.jetbrains.kotlin.analysis.api.analyze
// Import ClassId for identifying the @Screen annotation class.
import org.jetbrains.kotlin.name.ClassId
// Import FqName for fully qualified name representation.
import org.jetbrains.kotlin.name.FqName
// Import Name for simple identifier representation.
import org.jetbrains.kotlin.name.Name
// Import KtClassOrObject which represents a Kotlin class or object declaration in the PSI tree.
import org.jetbrains.kotlin.psi.KtClassOrObject
// Import KtObjectDeclaration which represents an object declaration (including companion objects).
import org.jetbrains.kotlin.psi.KtObjectDeclaration
// Import KtProperty which represents a property declaration in the PSI tree.
import org.jetbrains.kotlin.psi.KtProperty

// Documentation provider that generates Quick Documentation (Ctrl+Q / F1) for the
// Screen compiler plugin's generated KEY property.
// When a developer hovers over or requests documentation for the KEY property in a
// @Screen-annotated class's companion object, this provider shows:
//   - The property declaration: const val KEY: String = "com.example.MyFragment"
//   - A note that it was generated by the Screen compiler plugin
//   - A description of the property's purpose
//
// Registered in plugin.xml as a lang.documentationProvider for the Kotlin language.
class ScreenDocumentationProvider : AbstractDocumentationProvider() {

    // ClassId for the @Screen annotation, used to verify the owner class is annotated.
    private val screenClassId = ClassId(
        FqName("com.adkhambek.screen"),
        Name.identifier("Screen"),
    )

    // Called by the IDE when documentation is requested for a PSI element.
    // Returns an HTML string with the documentation, or null if this provider
    // doesn't handle the given element.
    override fun generateDoc(element: PsiElement, originalElement: PsiElement?): String? {
        // Only handle property declarations.
        val property = element as? KtProperty ?: return null
        val propName = property.name ?: return null
        // Only handle the "KEY" property.
        if (propName != "KEY") return null

        // Navigate up the PSI tree to find the companion object.
        // PSI tree: KtProperty -> KtClassBody -> KtObjectDeclaration (companion)
        val companion = property.parent?.parent as? KtObjectDeclaration ?: return null
        // Verify it's actually a companion object (not a regular object).
        if (!companion.isCompanion()) return null
        // Navigate to the outer class (the @Screen-annotated class).
        val ownerClass = companion.parent?.parent as? KtClassOrObject ?: return null
        // Get the FQN of the owner class (this becomes the KEY value).
        val ownerFqName = ownerClass.fqName?.asString() ?: return null
        // Verify the owner class has the @Screen annotation.
        if (!hasScreenAnnotation(ownerClass)) return null

        // Build and return the HTML documentation.
        return buildDocHtml(propName, ownerFqName)
    }

    // Builds an HTML documentation string for the given property.
    // The documentation includes the property declaration, a generation notice,
    // and a description of what the property is used for.
    private fun buildDocHtml(propName: String, ownerFqName: String): String {
        // The KEY value is the fully qualified name of the owner class.
        val value = if (propName == "KEY") ownerFqName else return ""
        // Description of the KEY property's purpose.
        val description = if (propName == "KEY") {
            "Bundle argument key for passing data to this component."
        } else ""

        return buildString {
            // Definition section: shows the property declaration with its constant value.
            append("<div class='definition'><pre>")
            append("const val $propName: String = \"$value\"")
            append("</pre></div>")
            // Content section: shows the generation notice and description.
            append("<div class='content'>")
            append("<p><i>Generated by the Screen compiler plugin</i></p>")
            append("<p>$description</p>")
            append("</div>")
        }
    }

    // Checks whether a class or object has the @Screen annotation.
    // Uses the Kotlin Analysis API (analyze block) to inspect the symbol's annotations.
    private fun hasScreenAnnotation(classOrObject: KtClassOrObject): Boolean {
        analyze(classOrObject) {
            val symbol = classOrObject.symbol
            return symbol.annotations.any { it.classId == screenClassId }
        }
    }
}
